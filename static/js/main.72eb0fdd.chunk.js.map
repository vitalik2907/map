{"version":3,"sources":["types/index.tsx","defaults/index.tsx","helpers/converters.tsx","helpers/coordinators.tsx","helpers/math.tsx","tiles/tile.tsx","components/Grid/index.tsx","tiles/index.tsx","components/Layout/index.tsx","components/MarkersLayout/index.tsx","components/Map/index.tsx","serviceWorker.ts","index.tsx","components/MarkersLayout/marker.png"],"names":["ControlState","InputType","defaultMapSize","height","width","defaultTileSize","defaultTilesCount","defaultDelta","x","y","defaultPosition","latToTile","lat","zoom","Math","floor","log","tan","PI","cos","pow","lngToTile","lng","tileToLng","tileToLat","n","atan","exp","latToY","lngToX","coordinatesToTile","coordinates","tileToCoordinates","position","latToKm","lngToKm","kmTolat","km","coordinatesOnTile","tileSize","arguments","length","undefined","startPosition","endPosition","start","end","coordinatesOnPositionedTile","getCoordinates","cursorPosition","delta","startTile","tilesCount","displayMapSize","getTilesCount","result","ceil","getCursorPosition","event","element","clientX","getBoundingClientRect","left","clientY","top","minusPositions","minuend","subtrahend","sumPositions","addend1","addend2","Tile","onload","_this","this","Object","classCallCheck","image","getImage","isTile","react_default","a","createElement","src","concat","onLoad","list","TilesList","isHiddenLoadingStarted","center","getTile","tile","find","item","hiddenLoading","push","setCurentMapState","continueHiddenLoading","findTile","findIndex","findNextPosition","round","i","j","abs","k","centerPlus","centerMinus","tilesRefs","Array","tilesGrid","Grid","props","startTilePosition","_useState","useState","_useState2","slicedToArray","useEffect","Fragment","map","row","rowIndex","style","key","cell","collIndex","float","backgroundColor","Layout","setTilesCount","_useState3","_useState4","marginLeft","marginTop","Grid_Grid","MarkersLayout","_React$useState","React","_React$useState2","canvas","setCanvas","_React$useState3","_React$useState4","size","ctx","getContext","img","Image","clearRect","markers","forEach","fillStyle","drawImage","squares","color","strokeStyle","beginPath","moveTo","points","lineTo","filled","fill","stroke","rounds","arc","radius","line","polygon","react","ref","styles","controlFlowStyle","helpFlowStyle","Boolean","window","location","hostname","match","mapProps","onMouseMove","clickNumber","inputMethod","Line","Circle","delLat","delLng","sqrt","Polygon","onClick","setClickNumber","Marker","onDoubleClick","pop","ReactDOM","render","objectSpread","overflow","userSelect","setZoom","setCenter","_useState5","_useState6","setMap","_useState7","_useState8","mapSize","setMapSize","_useState9","_useState10","dragable","setDragable","_useState11","_useState12","setCursorPosition","_useState13","_useState14","cursorStartPosition","setCursorStartPosition","_useState15","_useState16","_useState17","_useState18","setDelta","_useState19","_useState20","setStartTile","_useState21","_useState22","previousDelta","setPreviousDelta","_useState23","_useState24","currentCoordinates","setCurrentCoordinates","_useState25","Default","_useState26","_useState27","_useState28","_useState29","_useState30","_useState31","_useState32","_useState33","_useState34","_useState35","_useState36","_useState37","_useState38","_useState39","Cursor","_useState40","setInputMethod","getComputedStyle","parseFloat","paddingTop","paddingBottom","borderTopWidth","borderBottomWidth","paddingLeft","paddingRight","borderLeftWidth","borderRightWidth","getElementSize","count","d","changedDelta","vector","console","Layout_Layout","MarkersLayout_MarkersLayout","w","h","amendDelta","coords","onMouseUp","onMouseDown","onMouseLeave","onWheel","deltaY","assign","border","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","module","exports","__webpack_require__","p"],"mappings":"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","file":"static/js/main.72eb0fdd.chunk.js","sourcesContent":["export interface Size {\n    width: number;\n    height: number;\n}\n\nexport interface Position {\n    x: number;\n    y: number;\n}\n\nexport interface Coordinates {\n    lat: number;\n    lng: number;\n}\n\nexport interface Km {\n    km: number;\n}\n\nexport interface Marker {\n    lat: number;\n    lng: number;\n    image?: HTMLImageElement;\n    size?: Size;\n}\n\nexport interface Square {\n    points: Coordinates[];\n    filled: boolean;\n    color?: string;\n}\n\nexport interface Round {\n    center: Coordinates;\n    radius: Km;\n    filled: boolean;\n    color?: string;\n}\n\nexport interface Line {\n    points: Coordinates[];\n    filled: boolean;\n    color?: string;\n}\n\nexport interface Polygon {\n    points: Coordinates[];\n    filled: boolean;\n    color?: string;\n}\n\nexport enum ControlState {\n    Default = 0,\n    Marker = 1,\n    Square = 2,\n    Line = 3,\n    Polygon = 4,\n}\n\nexport enum InputType {\n    Circle,\n    Line,\n    Polygon,\n    Marker,\n\tCursor,\n}\n","import {\n    Position,\n    Size,\n} from '../types';\n\nexport const defaultMapSize: Size = {\n    height: 400,\n    width: 400,\n};\n\nexport const defaultTileSize: Size = {\n    height: 256,\n    width: 256,\n};\n\nexport const defaultTilesCount: Size = {\n    height: 5,\n    width: 5,\n};\n\nexport const defaultDelta: Position = {\n    x: 0,\n    y: 0,\n};\n\nexport const defaultPosition: Position = {\n    x: 0,\n    y: 0,\n};\n","import {\n    defaultTileSize,\n} from '../defaults';\nimport {\n    Coordinates,\n    Position,\n    Size,\n} from '../types';\n\nexport const latToTile = (lat: number, zoom: number): number => Math.floor(\n    (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) /\n    2 * Math.pow(2, zoom)\n);\n\nexport const lngToTile = (lng: number, zoom: number): number => Math.floor((lng + 180) / 360 * Math.pow(2, zoom));\n\nexport const tileToLng = (x: number, zoom: number): number => (((x / Math.pow(2, zoom)) * 360 - 180));\n\nexport const tileToLat = (y: number, zoom: number): number => {\n    const n = Math.PI - 2 * Math.PI * y / Math.pow(2, zoom);\n    return (180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))));\n};\n\nexport const latToY = (lat: number, zoom: number): number =>\n    (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) /\n    2 * Math.pow(2, zoom);\n\nexport const lngToX = (lng: number, zoom: number): number => (lng + 180) / 360 * Math.pow(2, zoom);\n\nexport const coordinatesToTile = (coordinates: Coordinates, zoom: number): Position => ({\n    x: lngToTile(coordinates.lng, zoom),\n    y: latToTile(coordinates.lat, zoom),\n});\n\nexport const tileToCoordinates = (position: Position, zoom: number) => ({\n    lng: tileToLng(position.x, zoom),\n    lat: tileToLat(position.y, zoom),\n});\n\nexport const latToKm = (lat: number): number => ((lat * 110.574));\n\nexport const lngToKm = (lng: number, lat: number): number => ((lng * 111.320) * Math.cos(lat *  Math.PI / 180));\n\nexport const kmTolat = (km: number): number => ((km / 110.574));\n\nexport const kmTolng = (km: number): number => ((km / 111.320) * Math.cos(kmTolat(km) *  Math.PI / 180));\n\nexport const coordinatesOnPositionedTile = (\n    coordinates: Coordinates,\n    zoom: number,\n    tileSize: Size = defaultTileSize,\n    startPosition: Position,\n    endPosition: Position\n): Position => {\n    const start = tileToCoordinates(startPosition, zoom);\n    const end = tileToCoordinates(endPosition, zoom);\n    return {\n        x: (coordinates.lng - start.lng) * tileSize.width / (end.lng - start.lng),\n        y: (coordinates.lat - start.lat) * tileSize.height / (end.lat - start.lat),\n    };\n};\n\nexport const coordinatesOnTile = (\n    coordinates: Coordinates,\n    zoom: number,\n    tileSize: Size = defaultTileSize\n): Position => {\n    const startPosition = coordinatesToTile(coordinates, zoom);\n    const endPosition = {\n        x: startPosition.x + 1,\n        y: startPosition.y + 1,\n    };\n    return coordinatesOnPositionedTile(coordinates, zoom, tileSize, startPosition, endPosition);\n};\n\nexport const invertPosition = (position: Position): Position =>\n    ({\n        x: -position.x,\n        y: -position.y,\n    });\n\nexport const getCoordinates = (\n    cursorPosition: Position,\n    delta: Position,\n    startTile: Position,\n    tilesCount: Size,\n    displayMapSize: Size,\n    tileSize: Size,\n    zoom: number\n): Coordinates => {\n    const start = tileToCoordinates(startTile, zoom);\n    const end = tileToCoordinates(\n        {\n            x: startTile.x + tilesCount.width,\n            y: startTile.y + tilesCount.height,\n        },\n        zoom\n    );\n    return {\n        lng: (cursorPosition.x - delta.x) * (end.lng - start.lng) / (tilesCount.width * tileSize.width) + start.lng,\n        lat: (cursorPosition.y - delta.y) * (end.lat - start.lat) / (tilesCount.height * tileSize.height) + start.lat,\n    };\n};\n","import {\n    Coordinates,\n    Position,\n    Size,\n} from '../types';\n\nexport const getElementWidth = (element: HTMLDivElement | null): number => {\n    if (!element) {\n        return 0;\n    }\n    const style = window.getComputedStyle(element, null);\n    return element.getBoundingClientRect().width -\n        parseFloat(style.paddingLeft || '0') -\n        parseFloat(style.paddingRight || '0') -\n        parseFloat(style.borderLeftWidth || '0') -\n        parseFloat(style.borderRightWidth || '0');\n};\n\nexport const getElementHeight = (element: HTMLDivElement | null): number => {\n    if (!element) {\n        return 0;\n    }\n    const style = window.getComputedStyle(element, null);\n    return element.getBoundingClientRect().height -\n        parseFloat(style.paddingTop || '0') -\n        parseFloat(style.paddingBottom || '0') -\n        parseFloat(style.borderTopWidth || '0') -\n        parseFloat(style.borderBottomWidth || '0');\n};\n\nexport const getElementSize = (element: HTMLDivElement | HTMLCanvasElement | null): Size => {\n    if (!element) {\n        return {\n            height: 0,\n            width: 0,\n        };\n    }\n    const style = window.getComputedStyle(element, null);\n    return {\n        height: element.getBoundingClientRect().height -\n            parseFloat(style.paddingTop || '0') -\n            parseFloat(style.paddingBottom || '0') -\n            parseFloat(style.borderTopWidth || '0') -\n            parseFloat(style.borderBottomWidth || '0'),\n        width: element.getBoundingClientRect().width -\n            parseFloat(style.paddingLeft || '0') -\n            parseFloat(style.paddingRight || '0') -\n            parseFloat(style.borderLeftWidth || '0') -\n            parseFloat(style.borderRightWidth || '0'),\n    };\n};\n\nexport const getTilesCount = (displayMapSize: Size, tileSize: Size): Size => {\n    const result: Size = {\n        height: Math.ceil(displayMapSize.height / tileSize.height) + 2,\n        width: Math.ceil(displayMapSize.width / tileSize.width) + 2,\n    };\n    result.height += result.height % 2 === 0 ? 1 : 0;\n    result.width += result.width % 2 === 0 ? 1 : 0;\n\n    return result;\n};\n\nexport const getCursorPosition = (event: React.MouseEvent<Element>, element: HTMLDivElement | null): Position => {\n    if (!element) {\n        return {\n            x: 0,\n            y: 0,\n        };\n    }\n    return {\n        x: event.clientX - element.getBoundingClientRect().left,\n        y: event.clientY - element.getBoundingClientRect().top,\n    };\n};\n\nexport const getCursorCoordinates = (\n    event: React.MouseEvent<Element>,\n    element: HTMLDivElement | null,\n    delta: Position\n): Coordinates => (\n    // const position: Position = getCursorPosition(event, element);\n    {\n        lat: 0,\n        lng: 0,\n    }\n);\n\nexport const amendDelta = (delta: Position, tileSize: Size, mapSize: Size) => {\n    const d = {\n        ...delta,\n    };\n    const w = (tileSize.width - (mapSize.width - Math.floor(mapSize.width / tileSize.width) * tileSize.width)) / 2;\n    const h = (tileSize.height - (mapSize.height - Math.floor(mapSize.height / tileSize.height) * tileSize.height)) / 2;\n    while (tileSize.width + w > -d.x) {\n        d.x -= tileSize.width;\n    }\n    while (tileSize.width * 2 + w < -d.x) {\n        d.x += tileSize.width;\n    }\n    while (tileSize.height + h > -d.y) {\n        d.y -= tileSize.height;\n    }\n    while (tileSize.height * 2 + h < -d.y) {\n        d.y += tileSize.height;\n    }\n    return d;\n};\n","import { Position } from '../types';\n\nexport const minusPositions = (minuend: Position, subtrahend: Position) => ({\n    x: minuend.x - subtrahend.x,\n    y: minuend.y - subtrahend.y,\n});\n\nexport const sumPositions = (addend1: Position, addend2: Position) => ({\n    x: addend1.x + addend2.x,\n    y: addend1.y + addend2.y,\n});\n","import React from 'react';\nimport { coordinatesToTile } from '../helpers';\nimport { Coordinates, Position } from '../types';\nimport { loadTile } from './loader';\n\nexport class Tile {\n    private zoom: number;\n    private coordinates: Coordinates;\n    // tslint:disable-next-line:no-any\n    private image: any;\n\n    public constructor(zoom: number, coordinates: Coordinates, onload: () => void) {\n        this.zoom = zoom;\n        this.coordinates = coordinates;\n        this.image = (\n            <img\n                src={`https://maps.wikimedia.org/osm-intl/${zoom}/${coordinates.lng}/${coordinates.lat}.png`}\n                onLoad={onload}\n            />\n        );\n        // this.image.src = `https://maps.wikimedia.org/osm-intl/${zoom}/${coordinates.lng}/${coordinates.lat}.png`;\n    }\n\n    public getImage = (): HTMLImageElement =>\n        this.image\n\n    public isTile = (zoom: number, coordinates: Coordinates) => (\n        this.zoom === zoom &&\n        this.coordinates.lat === coordinates.lat &&\n        this.coordinates.lng === coordinates.lng\n    )\n\n    public getCoordinates = (): Coordinates => this.coordinates;\n}\n","import React, { useEffect, useState } from 'react';\n\nimport {\n    TilesList,\n} from '../../tiles';\nimport {\n    Coordinates,\n    Position,\n    Size,\n} from '../../types';\n\nexport interface GridProps {\n    tilesCount: Size;\n    tileSize: Size;\n    center: Coordinates;\n    startTilePosition: Position;\n    zoom: number;\n}\n\nconst list = new TilesList();\nconst tilesRefs = new Array();\nconst tilesGrid = new Array();\n\nexport const Grid = (props: GridProps) => {\n    const {\n        tilesCount,\n        tileSize,\n        center,\n        zoom,\n        startTilePosition,\n    } = props;\n    // console.log(tilesCount);\n    for (let i = 0; i < tilesCount.height; i++) {\n        tilesGrid[i] = new Array();\n        tilesRefs[i] = new Array();\n\n        for (let j = 0; j < tilesCount.width; j++) {\n            tilesGrid[i][j] = list.getTile(\n                zoom,\n                {\n                    lat: startTilePosition.y + i,\n                    lng: startTilePosition.x + j,\n                }\n            ).getImage();\n        }\n    }\n\n    const [loadedTiles, setLoadTiles] = useState<number>(0);\n\n    useEffect(\n        () => {\n            // console.log(1);\n        },\n        [center]\n    );\n\n    return (\n        <>\n            {\n                tilesGrid.map((row: HTMLImageElement[], rowIndex: number) => (\n                    <div\n                        style={{\n                            height: `${tileSize.height}px`,\n                            width: `${tileSize.width * tilesCount.width}px`,\n                        }}\n                        key={rowIndex}\n                    >\n                        {\n                            row.map((cell: HTMLImageElement, collIndex: number) => (\n                                <div\n                                    style={{\n                                        float: 'left',\n                                        height: `${tileSize.height}px`,\n                                        width: `${tileSize.width}px`,\n                                        backgroundColor:\n                                            rowIndex === Math.floor(tilesCount.height / 2) &&\n                                            collIndex === Math.floor(tilesCount.width / 2) ?\n                                            'rgba(0, 255, 0, 0.5)' : '#fff',\n                                    }}\n                                    key={collIndex}\n                                >\n                                    {cell}\n                                </div>\n                            ))\n                        }\n                    </div>\n                ))\n            }\n        </>\n    );\n};\n","import React from 'react';\nimport { coordinatesToTile } from '../helpers';\nimport { Coordinates, Position } from '../types';\nimport { loadTile } from './loader';\nimport { Tile } from './tile';\n\nexport class TilesList {\n    private list: Tile[] = [];\n    private isHiddenLoadingStarted: boolean = false;\n    private center: Coordinates = {\n        lat: 0,\n        lng: 0,\n    };\n    private zoom: number = 0;\n\n    public getTile = (zoom: number, coordinates: Coordinates) => {\n        let tile = this.list.find(\n            (item: Tile) => item.isTile(zoom, coordinates)\n        );\n        if (tile === undefined) {\n            tile = new Tile(zoom, coordinates, this.hiddenLoading);\n            this.list.push(tile);\n        }\n        return tile;\n    }\n\n    public setCurentMapState = (center: Coordinates, zoom: number) => {\n        this.center = center;\n        this.zoom = zoom;\n    }\n\n    private continueHiddenLoading = () => {\n        // this.continueHiddenLoading();\n    }\n\n    private findTile = (zoom: number, coordinates: Coordinates) => {\n        const index = this.list.findIndex(\n            (item: Tile) => item.isTile(\n                zoom,\n                coordinates\n            )\n        );\n        if (index === -1) {\n            return {\n                zoom,\n                coordinates,\n            };\n        }\n        return null;\n    }\n\n    private findNextPosition = (round: number) => {\n        const center = coordinatesToTile(this.center, this.zoom);\n        for (let i = -round; i <= round; i++) {\n            for (let j = -round; j <= round; j++) {\n                if (Math.abs(i) === round || Math.abs(j) === round) {\n                    const tile = this.findTile(\n                        this.zoom,\n                        {\n                            lat: center.y + i,\n                            lng: center.x + j,\n                        }\n                    );\n                    if (tile != null) {\n                        return tile;\n                    }\n                }\n            }\n        }\n\n        for (let k = 1; k <= round; k++) {\n            const centerPlus = coordinatesToTile(this.center, this.zoom + k);\n            const centerMinus = coordinatesToTile(this.center, this.zoom - k);\n\n            for (let i = -round; i <= round; i++) {\n                for (let j = -round; j <= round; j++) {\n                    if (Math.abs(i) === round || Math.abs(j) === round) {\n                        let tile = this.findTile(\n                            this.zoom + k,\n                            {\n                                lat: centerPlus.y + i,\n                                lng: centerPlus.x + j,\n                            }\n                        );\n                        if (tile != null) {\n                            return tile;\n                        }\n                        tile = this.findTile(\n                            this.zoom - k,\n                            {\n                                lat: centerMinus.y + i,\n                                lng: centerMinus.x + j,\n                            }\n                        );\n                        if (tile != null) {\n                            return tile;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private hiddenLoading = () => {\n        if (this.isHiddenLoadingStarted) {\n            return;\n        }\n        this.isHiddenLoadingStarted = true;\n\n        let tile = null;\n        let i = 0;\n        do {\n            tile = this.findNextPosition(i);\n            i++;\n        } while (tile === null);\n\n        this.continueHiddenLoading();\n    }\n}\n","import React, {\n    useEffect,\n    useState,\n} from 'react';\nimport {\n    defaultDelta,\n    defaultTilesCount,\n    defaultTileSize,\n} from '../../defaults';\nimport {\n    getTilesCount,\n} from '../../helpers';\nimport {\n    Coordinates,\n    Position,\n    Size,\n} from '../../types';\nimport { Grid } from '../Grid';\n\nexport interface LayoutProps {\n    displayMapSize: Size;\n    delta: Position;\n    center: Coordinates;\n    startTilePosition: Position;\n    zoom: number;\n}\n\nexport const Layout = (props: LayoutProps) => {\n    const {\n        displayMapSize,\n        delta,\n        center,\n        startTilePosition,\n        zoom,\n    } = props;\n\n    const [tilesCount, setTilesCount] = useState(defaultTilesCount);\n    const [margins, setMargins] = useState(defaultDelta);\n\n    useEffect(\n        () => {\n            setTilesCount(getTilesCount(displayMapSize, defaultTileSize));\n        },\n        [displayMapSize]\n    );\n\n    return (\n        <div\n            style={{\n                height: `${defaultTileSize.height * tilesCount.height}px`,\n                marginLeft: `${delta.x}px`,\n                marginTop: `${delta.y}px`,\n                width: `${defaultTileSize.width * tilesCount.width}px`,\n            }}\n        >\n            <Grid\n                tilesCount={tilesCount}\n                tileSize={defaultTileSize}\n                center={center}\n                startTilePosition={startTilePosition}\n                zoom={props.zoom}\n            />\n        </div>\n    );\n};\n","import * as React from 'react';\nimport { defaultTilesCount, defaultTileSize } from '../../defaults';\nimport { getTilesCount, kmTolat, kmTolng, latToY, lngToX } from '../../helpers';\nimport { Line, Marker, Position, Round, Size, Square, Polygon } from '../../types';\nimport image from './marker.png';\n\nexport interface MarkersLayoutProps {\n    markers: Marker[];\n    squares: Square[];\n    rounds: Round[];\n    line: Line[];\n    polygon: Polygon[];\n    size: Size;\n    zoom: number;\n    delta: Position;\n    startTilePosition: Position;\n}\n\nexport const MarkersLayout: React.FC<MarkersLayoutProps> = (props: MarkersLayoutProps) => {\n    const [canvas, setCanvas] = React.useState<HTMLCanvasElement | null>(null);\n    const [tilesCount, setTilesCount] = React.useState(defaultTilesCount);\n\n    React.useEffect(\n        () => {\n            setTilesCount(getTilesCount(props.size, defaultTileSize));\n        },\n        [props.size]\n    );\n\n    React.useEffect(() => {\n        if (canvas) {\n            const ctx = canvas.getContext('2d');\n            if (ctx) {\n                const img = new Image();\n                img.src = image;\n                ctx.clearRect(0, 0, props.size.width, props.size.height);\n\n                // markers\n                props.markers.forEach((item: Marker) => {\n                    ctx.fillStyle = 'rgba(0, 0, 200, 0.5)';\n                    const size: Size = item.size || {\n                        width: 20,\n                        height: 32,\n                    };\n                    ctx.drawImage(\n                        img,\n                        (lngToX(item.lng, props.zoom) - props.startTilePosition.x) *\n                        tilesCount.width *\n                        defaultTileSize.width /\n                        tilesCount.width + props.delta.x - size.width / 2,\n\n                        (latToY(item.lat, props.zoom) - props.startTilePosition.y) *\n                        tilesCount.height *\n                        defaultTileSize.height /\n                        tilesCount.height + props.delta.y - size.height,\n                        size.width,\n                        size.height\n                    );\n                });\n\n                // squares\n                props.squares.forEach((item: Square) => {\n                    if (item.color) {\n                        ctx.fillStyle = item.color;\n                        ctx.strokeStyle = item.color;\n                    } else {\n                        ctx.fillStyle = '#000000';\n                        ctx.strokeStyle = '#000000';\n                    }\n                    ctx.beginPath();\n\n                    ctx.moveTo(\n                        (lngToX(item.points[0].lng, props.zoom) - props.startTilePosition.x) *\n                        tilesCount.width *\n                        defaultTileSize.width /\n                        tilesCount.width + props.delta.x,\n\n                        (latToY(item.points[0].lat, props.zoom) - props.startTilePosition.y) *\n                        tilesCount.height *\n                        defaultTileSize.height /\n                        tilesCount.height + props.delta.y\n                    );\n\n                    for (let i = 1; i < item.points.length; i++) {\n                        ctx.lineTo(\n                            (lngToX(item.points[i].lng, props.zoom) - props.startTilePosition.x) *\n                            tilesCount.width *\n                            defaultTileSize.width /\n                            tilesCount.width + props.delta.x,\n\n                            (latToY(item.points[i].lat, props.zoom) - props.startTilePosition.y) *\n                            tilesCount.height *\n                            defaultTileSize.height /\n                            tilesCount.height + props.delta.y\n                        );\n                    }\n\n                    ctx.lineTo(\n                        (lngToX(item.points[0].lng, props.zoom) - props.startTilePosition.x) *\n                        tilesCount.width *\n                        defaultTileSize.width /\n                        tilesCount.width + props.delta.x,\n\n                        (latToY(item.points[0].lat, props.zoom) - props.startTilePosition.y) *\n                        tilesCount.height *\n                        defaultTileSize.height /\n                        tilesCount.height + props.delta.y\n                    );\n\n                    if (item.filled) {\n                        ctx.fill();\n                    } else {\n                        ctx.stroke();\n                    }\n                });\n\n                props.rounds.forEach((item: Round) => {\n                    if (item.color) {\n                        ctx.fillStyle = item.color;\n                        ctx.strokeStyle = item.color;\n                    } else {\n                        ctx.fillStyle = '#000000';\n                        ctx.strokeStyle = '#000000';\n                    }\n                    ctx.beginPath();\n                    const center: Position = {\n                        x: lngToX(item.center.lng, props.zoom),\n                        y: latToY(item.center.lat, props.zoom),\n                    };\n                    ctx.arc(\n                        (center.x  - props.startTilePosition.x) *\n                        tilesCount.width *\n                        defaultTileSize.width /\n                        tilesCount.width + props.delta.x,\n                        (center.y - props.startTilePosition.y) *\n                        tilesCount.height *\n                        defaultTileSize.height /\n                        tilesCount.height + props.delta.y,\n                        //(Math.abs(lngToX(item.center.lng + kmTolng(item.radius.km), props.zoom) - center.x)) *\n                        //tilesCount.width *\n                        //defaultTileSize.width /\n                        //tilesCount.width,\n                        (Math.abs(latToY(item.center.lat + kmTolat(item.radius.km), props.zoom) - center.y)) *\n                        tilesCount.height *\n                        defaultTileSize.height /\n                        tilesCount.height,\n                        0,\n                        //0,\n                        2 * Math.PI\n                    );\n\n                    if (item.filled) {\n                        ctx.fill();\n                    } else {\n                        ctx.stroke();\n                    }\n                });\n\n                // line\n                props.line.forEach((item: Square) => {\n                    if (item.color) {\n                        ctx.fillStyle = item.color;\n                        ctx.strokeStyle = item.color;\n                    } else {\n                        ctx.fillStyle = '#000000';\n                        ctx.strokeStyle = '#000000';\n                    }\n                    ctx.beginPath();\n\n                    ctx.moveTo(\n                        (lngToX(item.points[0].lng, props.zoom) - props.startTilePosition.x) *\n                        tilesCount.width *\n                        defaultTileSize.width /\n                        tilesCount.width + props.delta.x,\n\n                        (latToY(item.points[0].lat, props.zoom) - props.startTilePosition.y) *\n                        tilesCount.height *\n                        defaultTileSize.height /\n                        tilesCount.height + props.delta.y\n                    );\n\n                    for (let i = 1; i < item.points.length; i++) {\n                        ctx.lineTo(\n                            (lngToX(item.points[i].lng, props.zoom) - props.startTilePosition.x) *\n                            tilesCount.width *\n                            defaultTileSize.width /\n                            tilesCount.width + props.delta.x,\n\n                            (latToY(item.points[i].lat, props.zoom) - props.startTilePosition.y) *\n                            tilesCount.height *\n                            defaultTileSize.height /\n                            tilesCount.height + props.delta.y\n                        );\n                    }\n\n                    if (item.filled) {\n                        ctx.fill();\n                    } else {\n                        ctx.stroke();\n                    }\n                });\n\n                // polygon\n                props.polygon.forEach((item: Square) => {\n                    if (item.color) {\n                        ctx.fillStyle = item.color;\n                        ctx.strokeStyle = item.color;\n                    } else {\n                        ctx.fillStyle = '#000000';\n                        ctx.strokeStyle = '#000000';\n                    }\n                    ctx.beginPath();\n\n                    ctx.moveTo(\n                        (lngToX(item.points[0].lng, props.zoom) - props.startTilePosition.x) *\n                        tilesCount.width *\n                        defaultTileSize.width /\n                        tilesCount.width + props.delta.x,\n\n                        (latToY(item.points[0].lat, props.zoom) - props.startTilePosition.y) *\n                        tilesCount.height *\n                        defaultTileSize.height /\n                        tilesCount.height + props.delta.y\n                    );\n\n                    for (let i = 1; i < item.points.length; i++) {\n                        ctx.lineTo(\n                            (lngToX(item.points[i].lng, props.zoom) - props.startTilePosition.x) *\n                            tilesCount.width *\n                            defaultTileSize.width /\n                            tilesCount.width + props.delta.x,\n\n                            (latToY(item.points[i].lat, props.zoom) - props.startTilePosition.y) *\n                            tilesCount.height *\n                            defaultTileSize.height /\n                            tilesCount.height + props.delta.y\n                        );\n                    }\n                    ctx.lineTo(\n                        (lngToX(item.points[0].lng, props.zoom) - props.startTilePosition.x) *\n                        tilesCount.width *\n                        defaultTileSize.width /\n                        tilesCount.width + props.delta.x,\n\n                        (latToY(item.points[0].lat, props.zoom) - props.startTilePosition.y) *\n                        tilesCount.height *\n                        defaultTileSize.height /\n                        tilesCount.height + props.delta.y\n                    );\n\n                    if (item.filled) {\n                        ctx.fill();\n                    } else {\n                        ctx.stroke();\n                    }\n                });\n\n            }\n        }\n    });\n\n    return (\n        <canvas\n            style={{\n                width: '100%',\n                height: '100%',\n                position: 'absolute',\n                top: 0,\n                left: 0,\n            }}\n            width={props.size.width}\n            height={props.size.height}\n            ref={(element: HTMLCanvasElement) => setCanvas(element)}\n        />\n    );\n};\n","import React, {\n    CSSProperties,\n    useEffect,\n    useState,\n} from 'react';\n\nimport {\n    defaultDelta,\n    defaultMapSize,\n    defaultPosition,\n    defaultTilesCount,\n    defaultTileSize,\n} from '../../defaults';\nimport {\n    amendDelta,\n    coordinatesOnTile,\n    coordinatesToTile,\n    getCoordinates,\n    getCursorPosition,\n    getElementSize,\n    getTilesCount,\n    minusPositions,\n    sumPositions,\n} from '../../helpers';\nimport {\n    ControlState,\n    Coordinates,\n    InputType,\n    Line,\n    Marker,\n    Polygon,\n    Position,\n    Round,\n    Size,\n\tSquare,\n} from '../../types';\nimport { Layout } from '../Layout';\nimport { MarkersLayout } from '../MarkersLayout';\n\nconst styles = {\n    controlFlowStyle: {\n        height: '100%',\n        width: '100%',\n        left: 0,\n        position: 'absolute',\n        top: 0,\n    }  as CSSProperties,\n    helpFlowStyle: {\n        height: '50%',\n        width: '50%',\n        left: 0,\n        position: 'absolute',\n        top: 0,\n        backgroundColor: 'rgba(255, 0, 0, 0.25)',\n    }  as CSSProperties,\n};\n\nexport interface MapProps {\n    style?: CSSProperties;\n    onMouseMove?: (position: Position, coordinates: Coordinates, clickNumber: number, inputMethod: InputType) => void;\n    onMouseUp?: (event: React.MouseEvent) => void;\n    onMouseDown?: (event: React.MouseEvent) => void;\n    onClick?: (position: Position, coordinates: Coordinates, inputMethod: InputType, clickNumber: number, setClickNumber: (x:number) => void) => void;\n    onDoubleClick?: (event: React.MouseEvent, clickNumber: number, setClickNumber: (x:number) => void, inputMethod: InputType) => void;\n    center: Coordinates;\n    zoom: number;\n    markers: Marker[];\n    squares: Square[];\n    rounds: Round[];\n    line: Line[];\n    polygon: Polygon[];\n    //markersControlShow?: boolean;\n}\n\nexport const Map: React.FC<MapProps> = (props: MapProps) => {\n    const style: CSSProperties = {\n        position: 'relative',\n        ...props.style,\n        overflow: 'hidden',\n        userSelect: 'none',\n    } as CSSProperties;\n\n    // state\n    const [zoom, setZoom] = useState<number>(props.zoom);\n    const [center, setCenter] = useState<Coordinates>(props.center);\n    const [map, setMap] = useState<HTMLDivElement | null>(null);\n    const [mapSize, setMapSize] = useState<Size>(defaultMapSize);\n    const [dragable, setDragable] = useState<boolean>(false);\n    const [cursorPosition, setCursorPosition] = useState<Position>(defaultPosition);\n    const [cursorStartPosition, setCursorStartPosition] = useState<Position>(defaultPosition);\n    const [tilesCount, setTilesCount] = useState<Size>(defaultTilesCount);\n    const [delta, setDelta] = useState<Position>({\n        x: ((tilesCount.width - 1) * defaultTileSize.width - mapSize.width) / 2 + coordinatesOnTile(center, zoom).x,\n        y: ((tilesCount.height - 1) * defaultTileSize.height - mapSize.height) / 2 + coordinatesOnTile(center, zoom).y,\n    });\n    const [startTile, setStartTile] = useState<Position>(\n        minusPositions(\n            coordinatesToTile(center, zoom),\n            {\n                x: Math.floor(defaultTilesCount.width / 2),\n                y: Math.floor(defaultTilesCount.height / 2),\n            }\n        )\n    );\n    const [previousDelta, setPreviousDelta] = useState<Position>(delta);\n    const [currentCoordinates, setCurrentCoordinates] = useState<Coordinates>(center);\n    const [controlState, setControlState] = useState<ControlState>(ControlState.Default);\n    const [markers, setMarkers] = useState<Marker[]>(props.markers);\n    const [squares, setSquares] = useState<Square[]>(props.squares);\n    const [rounds, setRounds] = useState<Round[]>(props.rounds);\n    const [line, setLine] = useState<Line[]>(props.line);\n    const [clickNumber, setClickNumber] = useState<number>(0);\n    const [polygon, setPolygon] = useState<Polygon[]>(props.polygon);\n    const [inputMethod, setInputMethod] = useState<InputType>(InputType.Cursor);\n    // effects\n    useEffect(\n        () => {\n            const size = getElementSize(map);\n            setMapSize(size);\n\n            const count = getTilesCount(size, defaultTileSize);\n            setTilesCount(count);\n\n            const start = minusPositions(\n                coordinatesToTile(center, zoom),\n                {\n                    x: Math.floor(count.width / 2),\n                    y: Math.floor(count.height / 2),\n                }\n            );\n\n            setStartTile(start);\n\n            const d = {\n                x: - (((count.width - 1) * defaultTileSize.width - size.width) /\n                2 + coordinatesOnTile(center, zoom).x),\n                y: - (((count.height - 1) * defaultTileSize.height - size.height) /\n                2 + coordinatesOnTile(center, zoom).y),\n            };\n            setDelta(d);\n        },\n        [map, zoom]\n    );\n\n    useEffect(\n        () => {\n            const changedDelta = minusPositions(previousDelta, delta);\n            const vector: Position = {\n                x: - Math.round(changedDelta.x / defaultTileSize.width),\n                y: - Math.round(changedDelta.y / defaultTileSize.height),\n            };\n            if (Math.abs(vector.x) === 1 || Math.abs(vector.y) === 1) {\n                setStartTile(\n                    sumPositions(startTile, vector)\n                );\n            }\n            setPreviousDelta(delta);\n        },\n        [delta]\n    );\n\n    // handlers\n    const handleOnMouseMove = (event: React.MouseEvent) => {\n        const position = getCursorPosition(event, map);\n        setCursorPosition(position);\n        if (dragable) {\n            const d = amendDelta(\n                minusPositions(position, cursorStartPosition),\n                defaultTileSize,\n                mapSize\n            );\n            setDelta(d);\n            \n\t\t\t\t\t\t      props.onMouseMove && props.onMouseMove(position, currentCoordinates, clickNumber, inputMethod);\n        } else {\n            const coords = getCoordinates(\n                position,\n                delta,\n                startTile,\n                tilesCount,\n                mapSize,\n                defaultTileSize,\n                zoom\n            );\n            setCurrentCoordinates(coords);\n\t\t\t\t\t\t      props.onMouseMove && props.onMouseMove(position, coords, clickNumber, inputMethod);\n        }\n    };\n\n    const handleOnMouseUp = (event: React.MouseEvent) => {\n        setCursorStartPosition(\n            sumPositions(cursorPosition, delta)\n        );\n        setDragable(true);\n\t\t\t\t    props.onMouseUp && props.onMouseUp(event);\n    };\n\n    const handleOnMouseDown = (event: React.MouseEvent) => {\n        setCursorStartPosition(\n            minusPositions(cursorPosition, delta)\n        );\n        setDragable(true);\n\t\t\t\t    props.onMouseDown && props.onMouseDown(event);\n    };\n\n    const handleOnMouseClick = (event: React.MouseEvent) => {\n        const position = getCursorPosition(event, map);\n        // setCursorPosition(position);\n        console.log(currentCoordinates,previousDelta, cursorStartPosition);\n        if (dragable) {\n           /*const d = amendDelta(\n                minusPositions(position, cursorStartPosition),\n                defaultTileSize,\n                mapSize\n            );\n            setDelta(d);*/\n            // setCursorPosition(position);\n            setDragable(false);\n\t\t\t\t\t\t      props.onClick && props.onClick(position, currentCoordinates, inputMethod, clickNumber, setClickNumber);\n        } else {\n            console.log(position,\n                delta,\n                startTile,\n                );\n            const coords = getCoordinates(\n                position,\n                delta,\n                startTile,\n                tilesCount,\n                mapSize,\n                defaultTileSize,\n                zoom\n            );\n            setCurrentCoordinates(coords);\n            //setDragable(false);\n        \n                    props.onClick && props.onClick(position, coords, inputMethod, clickNumber, setClickNumber);\n        \n        }\n    };\n\n    const handleOnMouseDoubleClick = (event: React.MouseEvent) => {\n        setDragable(false);\n\t\t\t\t    props.onDoubleClick && props.onDoubleClick(event, clickNumber, setClickNumber, inputMethod);\n    };\n\n    const handleOnMouseLeave = (event: React.MouseEvent) => {\n        setDragable(false);\n    };\n\n    const handleOnMouseWheel = (event: React.WheelEvent) => {\n        if (event.deltaY > 0 && zoom > 4) {\n            setCenter(currentCoordinates);\n            setZoom(zoom - 1);\n        }\n        if (event.deltaY < 0 && zoom < 19) {\n            setCenter(currentCoordinates);\n            setZoom(zoom + 1);\n        }\n    };\n\n    useEffect(\n        () => {\n            console.log(inputMethod);\n        },\n        [inputMethod]\n    );\n\n    // render\n    return (\n\t\t<>\n\t\t\t{\n\t\t\t\t// props.markersControlShow && (\n                (\n\t\t\t\t\t<div>\n\t\t\t\t\t\t<button onClick={() => setInputMethod(InputType.Circle)}>Circle</button>\n\t\t\t\t\t\t<button onClick={() => setInputMethod(InputType.Line)}>Line</button>\n\t\t\t\t\t\t<button onClick={() => setInputMethod(InputType.Polygon)}>Polygon</button>\n\t\t\t\t\t\t<button onClick={() => setInputMethod(InputType.Marker)}>Marker</button>\n\t\t\t\t\t\t<button onClick={() => setInputMethod(InputType.Cursor)}>Cursor</button>\n\t\t\t\t\t</div>\n\t\t\t\t)\n\t\t\t}\n\t        <div style={style} ref={(element: HTMLDivElement) => setMap(element)}>\n\t            <Layout\n\t                displayMapSize={mapSize}\n\t                delta={delta}\n\t                center={center}\n\t                startTilePosition={startTile}\n                    zoom={zoom}\n\t            />\n\t            <MarkersLayout\n\t                markers={markers}\n\t                squares={squares}\n                    rounds={rounds}\n                    line={line}\n                    polygon={polygon}\n\t                delta={delta}\n\t                startTilePosition={startTile}\n\t                size={mapSize}\n\t                zoom={zoom}\n\t            />\n\t            <div\n\t                style={styles.controlFlowStyle}\n\t                onMouseMove={handleOnMouseMove}\n\t                onMouseUp={handleOnMouseUp}\n\t                onMouseDown={handleOnMouseDown}\n\t                onClick={handleOnMouseClick}\n\t                onDoubleClick={handleOnMouseDoubleClick}\n\t                onMouseLeave={handleOnMouseLeave}\n\t                onWheel={handleOnMouseWheel}\n\t            />\n\t        </div>\n\t\t</>\n    );\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React, { CSSProperties } from 'react';\nimport ReactDOM from 'react-dom';\nimport { Map, MapProps } from './components/Map';\nimport * as serviceWorker from './serviceWorker';\nimport { Coordinates, Position, InputType } from './types';\nimport {latToKm, lngToKm} from '../src/helpers/converters';\n\nconst style = {\n    border: 'solid 1px #000',\n    height: '800px',\n    left: '200px',\n    position: 'absolute',\n    top: '50px',\n    width: '800px',\n} as CSSProperties;\n\nconst mapProps: MapProps = {\n    center: {\n        lat: 50.1102,\n        lng: 3.1506,\n    },\n    zoom: 7,\n    markers: [\n        /*{\n            lat: 50.1102,\n            lng: 3.1506,\n        },\n        {\n            lat: 50.2102,\n            lng: 3.1506,\n        },\n        {\n            lat: 50.3102,\n            lng: 3.1506,\n        },\n        {\n            lat: 50.1102,\n            lng: 3.2506,\n        },\n        {\n            lat: 50.1102,\n            lng: 3.3506,\n        },\n        {\n            lat: 50.2102,\n            lng: 3.2506,\n        },\n        {\n            lat: 50.3102,\n            lng: 3.3506,\n        },*/\n    ],\n    squares: [\n        /*{\n            filled: false,\n            points: [\n                {\n                    lat: 50.1102,\n                    lng: 3.3506,\n                },\n                {\n                    lat: 50.2102,\n                    lng: 3.2506,\n                },\n                {\n                    lat: 50.3102,\n                    lng: 3.3506,\n                },\n            ],\n        },*/\n    ],\n    rounds: [\n        {\n            center: {\n                lat: 50.3102,\n                lng: 3.3506,\n            },\n            radius: {\n                km: 10,\n            },\n            filled: true,\n            color: 'rgba(255, 255, 0, 0.5)',\n        },\n    ],\n    line: [\n        {\n            filled: false,\n            points: [\n                {\n                    lat: 50.1102,\n                    lng: 3.1506,\n                },\n                {\n                    lat: 50.2102,\n                    lng: 3.1506,\n                },\n            ],\n        },\n    ],\n    polygon: [\n        {\n            filled: false,\n            points: [\n                {\n                    lat: 50.3102,\n                    lng: 3.1506,\n                },\n                {\n                    lat: 50.2102,\n                    lng: 3.2506,\n                },\n                {\n                    lat: 50.1102,\n                    lng: 3.2506,\n                },\n            ],\n        },\n    ],\n    onMouseMove (position: Position, coordinates: Coordinates, clickNumber: number, inputMethod: InputType) {\n        switch(inputMethod){\n            case(InputType.Line): {\n                if (clickNumber === 1){\n                    this.line[this.line.length - 1].points[1] = coordinates;\n                }\n                break;\n            }\n            case(InputType.Circle): {\n                if (clickNumber === 1){\n                    const delLat = this.rounds[this.rounds.length - 1].center.lat - coordinates.lat;\n                    const delLng = this.rounds[this.rounds.length - 1].center.lng - coordinates.lng;\n                    this.rounds[this.rounds.length - 1].radius.km = Math.sqrt((Math.pow(latToKm(delLat), 2) + (Math.pow(lngToKm(delLng, coordinates.lat), 2))));\n                }\n                break;\n            }\n            case(InputType.Polygon): {\n                if (clickNumber !== 0){\n                    this.polygon[this.polygon.length - 1].points[this.polygon[this.polygon.length - 1].points.length - 1] = coordinates;\n                }\n                break;\n            }\n        }\n    },\n    onClick(position: Position, coordinates: Coordinates, inputMethod: InputType, clickNumber: number, setClickNumber: (x:number) => void) {\n        switch(inputMethod){\n            case(InputType.Marker): {\n                this.markers.push(coordinates);\n                break;\n            }\n            case(InputType.Line): {\n                if (clickNumber === 0){\n                    setClickNumber(1);\n                    this.line.push(\n                        {\n                            filled: false,\n                            points: [\n                                coordinates,\n                                coordinates,\n                            ],\n                        },\n                    );\n                } else {\n                    setClickNumber(0);\n                    this.line[this.line.length - 1].points[1] = coordinates;\n                }\n                break;\n            }\n            case(InputType.Circle): {\n                if (clickNumber === 0){\n                    setClickNumber(1);\n                    this.rounds.push(\n                        {\n                            center: coordinates,\n                            radius: {\n                                km: 10,\n                            },\n                            filled: true,\n                            color: 'rgba(255, 255, 0, 0.5)',\n                        },\n                    );\n                } else {\n                    setClickNumber(0);\n                    const delLat = this.rounds[this.rounds.length - 1].center.lat - coordinates.lat;\n                    const delLng = this.rounds[this.rounds.length - 1].center.lng - coordinates.lng;\n                    this.rounds[this.rounds.length - 1].radius.km = Math.sqrt((Math.pow(latToKm(delLat), 2) + (Math.pow(lngToKm(delLng, coordinates.lat), 2))));\n                }\n                break;\n            }\n            case(InputType.Polygon): {\n                if (clickNumber === 0){\n                    setClickNumber(1);\n                    this.polygon.push(\n                        {\n                            filled: false,\n                            points: [\n                                coordinates,\n                                coordinates,\n                            ],\n                        },\n                    );\n                } else {\n                    setClickNumber(clickNumber + 1);\n                    this.polygon[this.polygon.length - 1].points[this.polygon[this.polygon.length - 1].points.length - 1] = coordinates;\n                    this.polygon[this.polygon.length - 1].points.push(coordinates);\n\n                }\n                break;\n            }\n        }\n    },\n    onDoubleClick(event: React.MouseEvent, clickNumber: number, setClickNumber: (x: number) => void, inputMethod: InputType) {\n        setClickNumber(0);\n        switch(inputMethod){\n            case(InputType.Marker): {\n                this.markers.pop();\n                this.markers.pop();\n                this.markers.pop();\n                // this.markers = this.markers.splice(0, this.markers.length - 4);\n                break;\n            }\n            case(InputType.Line): {\n                this.line.pop();\n                this.line.pop();\n                if (clickNumber === 1){\n                    setClickNumber(0);\n                }\n                break;\n            }\n            case(InputType.Circle): {\n                this.rounds.pop();\n                this.rounds.pop();\n                if (clickNumber === 1){\n                    setClickNumber(0);\n                }\n                break;\n            }\n            case(InputType.Polygon): {\n                if (clickNumber !== 2){\n                    setClickNumber(0);\n                    this.polygon[this.polygon.length - 1].points.pop();\n                    this.polygon[this.polygon.length - 1].points.pop();\n                    this.polygon[this.polygon.length - 1].points.pop();\n                } else {\n                    this.polygon.pop();\n                    this.polygon.pop();\n                }\n                \n                break;\n            }\n        }\n    }\n};\n\nReactDOM.render(\n    (\n        <Map\n            style={style}\n            {...mapProps}\n        />\n    ),\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = __webpack_public_path__ + \"static/media/marker.25a6aff3.png\";"],"sourceRoot":""}